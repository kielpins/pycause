import os
from collections import Counter
import inspect
import networkx as nx

import loaddata as load
from pcalg import pc
from sembuilder import sim_graph
from graphstat_pymc import lingauss

sim = lingauss

beta_range = (0.5,2)
stdev = 0.3
nsamp = 1000
sig = 2 # in units of standard deviation

#graph = nx.DiGraph([(0,3),(1,3),(2,3),(3,4),(2,4)])

graph = nx.DiGraph([(0,2),(1,2),(2,3)])
#graph = nx.DiGraph([(0,1)])

def test_disc_known_graph(graph, beta_range, stdev, nsamp, sig, ntrials, data_file='data.txt'):
    """
    Generate statistical data from a known graph, apply PC algorithm to the data, and compare the PC result to the
    known graph.
    Data is generated by Markov chain Monte Carlo (MCMC) simulations of a linear Gaussian model of the graph.
    :param graph: known graph from which data is generated
    :param beta_range: list [beta_min, beta_max] specifying range of linear coefficients for model
    :param stdev: standard deviation of Gaussian noise added to each node
    :param nsamp: number of samples in generated dataset
    :param sig: significance test parameter for inference (specified as standard deviation)
    :param ntrials: number of generation/inference trials, useful for obtaining statistics on success rate of inference
    :return: collections.Counter object with number of successes and failures
             dictionary of all distinct inferred graphs
    """

    dir_path = os.getcwd()
    data_path = os.path.join(dir_path, data_file)

    graph_key = tuple(sorted(graph.edges()))
    success_skel = list()
    success = list()
    graph_out = dict()
    for idx in range(ntrials):
        mc = sim(graph, beta_range, stdev, data_path) # simulate graph model
        statdat = load.load_file(data_path) # load simulation data
        discgrph, sepset = pc(statdat, sig, verbose=False) # infer graph from data
        # assign graph to key made from edges
        disc_key = tuple(sorted(discgrph.edges()))
        if disc_key not in graph_out.keys():
            graph_out[disc_key] = [discgrph]
        else:
            graph_out[disc_key].append(discgrph)
        discskel = discgrph.to_undirected()
        graphskel = graph.to_undirected()
        correct_skel = (discskel.edges() == graphskel.edges())
        correct = (disc_key == graph_key)
        success_skel.append(correct_skel)
        success.append(correct)
    return {'full': Counter(success), 'skel': Counter(success_skel)}, graph_out

if __name__ == '__main__':
    ctr, graph_out = test_disc_known_graph(graph, beta_range, stdev, nsamp, sig, 10)